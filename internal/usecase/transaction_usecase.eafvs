package usecase

import (
	"context"
	"fmt"
	"github/golang-developer-technical-test/internal/constant"
	"github/golang-developer-technical-test/internal/entity"
	"github/golang-developer-technical-test/internal/model"
	"github/golang-developer-technical-test/internal/repository"
	"github/golang-developer-technical-test/internal/util"
	"net/http"
	"sync"
	"time"

	"braces.dev/errtrace"
	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/sirupsen/logrus"
	"gorm.io/gorm"
)

type TranscationLoanUseCase struct {
	db                        *gorm.DB
	log                       *logrus.Logger
	validate                  *validator.Validate
	userRepository            *repository.UserRepository
	userTenorRepository       *repository.UserTenorRepository
	transcationLoanRepository *repository.TranscationLoanRepository
}

func NewTranscationLoanUseCase(db *gorm.DB, log *logrus.Logger, validate *validator.Validate, userRepository *repository.UserRepository, userTenorRepository *repository.UserTenorRepository, transcationLoanRepository *repository.TranscationLoanRepository) *TranscationLoanUseCase {
	return &TranscationLoanUseCase{
		db:                        db,
		log:                       log,
		validate:                  validate,
		userRepository:            userRepository,
		userTenorRepository:       userTenorRepository,
		transcationLoanRepository: transcationLoanRepository,
	}
}

func (c TranscationLoanUseCase) CreateLoan(ctx context.Context, req *model.RequestLoan) (interface{}, int, error) {
	tx := c.db.WithContext(ctx)

	if approvalStatus, err := c.userRepository.GetApprovalStatusById(tx, req.FkMsUser); err != nil {
		c.log.Warnf("Failed to get approvalStatus: %+v", err)
		return nil, http.StatusInternalServerError, errtrace.Wrap(err)
	} else if approvalStatus != constant.APPROVAL_STATUS_APPROVED {
		return nil, http.StatusForbidden, errtrace.Wrap(echo.ErrForbidden)
	}

	var userLimitTenor entity.MapUserTenor
	var total float64
	errChan := make(chan error, 2) // Channel to receive errors
	var wg sync.WaitGroup
	wg.Add(2)
	go func() {
		defer wg.Done()
		if Count,err := c.userTenorRepository.CountByWhere(tx, &userLimitTenor, map[string]interface{}{
			"fk_ms_user":  req.FkMsUser,
			"fk_ms_tenor": req.TenorId,
		}); err != nil {
			errChan <- err
		}
		if Count>0{
			
		}
		if
		return
	}()
	go func() {
		totalOtr, err := c.transcationLoanRepository.GetTotalNotPaidLoanByUserTenorId(tx, req.FkMsUser)
		if err != nil {
			errChan <- err
			return
		} else {
			total = totalOtr
			return
		}
	}()

	wg.Wait()
	close(errChan)

	for err := range errChan {
		if err != nil {
			fmt.Printf("Error occurred: %v\n", err)
		}
	}
	if req.OtrAmount > total {
		return nil, http.StatusNotAcceptable, errtrace.New("Not Enough Credit")
	}
	startTransaction := tx.Begin()
	defer func() {
		if startTransaction != nil {
			startTransaction.Rollback()
		}
	}()
	headerId, _ := uuid.NewV7()
	now := time.Now()
	stamp := entity.Stamp{
		CreatedBy: req.FkMsUser.String(),
		UpdatedAt: now,
		UpdatedBy: req.FkMsUser.String(),
		CreatedAt: now,
	}
	loanHeaderEntity := entity.TrLoanHeader{
		PkTrLoanHeader:    headerId,
		FkMsUser:          req.FkMsUser,
		FkMsPaymentStatus: constant.PAYMENT_STATUS_ACTIVE,
		FkMsItemType:      req.FkMsItemType,
		ContractNumber:    req.ContractNumber,
		AssetName:         req.AssetName,
		Stamp:             stamp,
	}
	loanDetailEntity := entity.TrLoanDetail{
		PkTrLoanDetail:  uuid.New(),
		FkTrLoanHeader:  headerId,
		FkMsSource:      req.FkMsSource,
		FkMapUserTenor:  userLimitTenor.PkMapUserTenor,
		OtrAmount:       req.OtrAmount,
		LoanBalance:     util.GenerateBasicInterest(req.OtrAmount,userLimitTenor.tenor),
		TransactionDate: now,
		DueDate:         now,
		Stamp:           stamp,
	}
	c.transcationLoanRepository.Header.Create()
	// c.userTenorRepository.FindByWhere(tx, UserLimitTenor)
	return nil, errtrace.Wrap(echo.ErrInternalServerError)
}
